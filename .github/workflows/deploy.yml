name: Build and Deploy

on:
  push:
    branches:
      - main
      # Note: 'dev' branch deployments are handled manually on Unraid

env:
  GHCR_REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      env: ${{ steps.env.outputs.env }}
      tag: ${{ steps.tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment
        id: env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "env=prod" >> $GITHUB_OUTPUT
          else
            echo "env=dev" >> $GITHUB_OUTPUT
          fi

      - name: Generate tag
        id: tag
        run: |
          GIT_TAG=$(git tag --sort=-version:refname | head -1 || echo "")
          
          if [ -n "$GIT_TAG" ]; then
            echo "tag=$GIT_TAG" >> $GITHUB_OUTPUT
            echo "‚úÖ Using git tag: $GIT_TAG"
          else
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            FALLBACK_TAG="${{ steps.env.outputs.env }}-${SHORT_SHA}"
            echo "tag=${FALLBACK_TAG}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No git tags found, using fallback: ${FALLBACK_TAG}"
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push images
        run: |
           ENV="${{ steps.env.outputs.env }}"
           TAG="${{ steps.tag.outputs.tag }}"
           
           # Define services to build
           declare -A SERVICES=(
             ["backend"]="./backend|Dockerfile"
             ["frontend"]="./frontend|Dockerfile"
             ["otel-collector"]="./monitoring|Dockerfile.otel.$ENV"
             ["prometheus"]="./monitoring|Dockerfile.prometheus"
             ["loki"]="./monitoring|Dockerfile.loki.$ENV"
             ["grafana"]="./monitoring|Dockerfile.grafana"
           )
           
           for SERVICE in "${!SERVICES[@]}"; do
             IFS='|' read -r CONTEXT DOCKERFILE <<< "${SERVICES[$SERVICE]}"
             
             echo "üê≥ Building hopper-$SERVICE..."
             
             # Build args for frontend
             BUILD_ARGS=""
             if [ "$SERVICE" == "frontend" ]; then
               BUILD_ARGS="--build-arg REACT_APP_BACKEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }} \
                           --build-arg REACT_APP_DOMAIN=${{ steps.env.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }} \
                           --build-arg REACT_APP_FRONTEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }} \
                           --build-arg REACT_APP_ENVIRONMENT=${{ steps.env.outputs.env == 'prod' && 'production' || 'development' }} \
                           --build-arg REACT_APP_VERSION=$TAG"
             elif [[ "$SERVICE" =~ ^(prometheus|grafana)$ ]]; then
               BUILD_ARGS="--build-arg ENV=$ENV"
             fi
             
             docker buildx build \
               "$CONTEXT" \
               --file "$CONTEXT/$DOCKERFILE" \
               --push \
               --cache-from type=gha \
               --cache-to type=gha,mode=max \
               --tag "${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-$SERVICE:$TAG" \
               --tag "${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-$SERVICE:$ENV-latest" \
               $BUILD_ARGS
           done

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_SSH_KEY || secrets.DEV_SSH_KEY }}

      - name: Set deployment variables
        id: vars
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          TAG="${{ needs.build-and-push.outputs.tag }}"
          
          # Set environment-specific variables
          if [ "$ENV" == "prod" ]; then
            echo "ssh_host=${{ secrets.PROD_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.PROD_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper" >> $GITHUB_OUTPUT
          else
            echo "ssh_host=${{ secrets.DEV_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.DEV_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper-dev" >> $GITHUB_OUTPUT
          fi
          
          # Generate short tag
          if [[ "$TAG" =~ ^v[0-9] ]]; then
            echo "short_tag=$TAG" >> $GITHUB_OUTPUT
          else
            echo "short_tag=$(echo "$TAG" | cut -d'-' -f2-)" >> $GITHUB_OUTPUT
          fi

      - name: Create environment file
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          
          # Create .env file with all secrets
          cat > .env.$ENV << 'ENVEOF'
          ENVIRONMENT=${{ needs.build-and-push.outputs.env == 'prod' && 'production' || 'development' }}
          LOG_LEVEL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_LOG_LEVEL || secrets.DEV_LOG_LEVEL }}
          DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }}
          FRONTEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }}
          BACKEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }}
          CLOUDFLARE_ACCESS_AUD_TAG=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_AUD_TAG || secrets.DEV_CLOUDFLARE_ACCESS_AUD_TAG }}
          CLOUDFLARE_ACCESS_TEAM_DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_TEAM_DOMAIN || secrets.DEV_CLOUDFLARE_ACCESS_TEAM_DOMAIN }}
          GOOGLE_CLIENT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_ID || secrets.DEV_GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_SECRET || secrets.DEV_GOOGLE_CLIENT_SECRET }}
          GOOGLE_PROJECT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_PROJECT_ID || secrets.DEV_GOOGLE_PROJECT_ID }}
          TIKTOK_CLIENT_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_KEY || secrets.DEV_TIKTOK_CLIENT_KEY }}
          TIKTOK_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_SECRET || secrets.DEV_TIKTOK_CLIENT_SECRET }}
          FACEBOOK_APP_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FACEBOOK_APP_ID || secrets.DEV_FACEBOOK_APP_ID }}
          FACEBOOK_APP_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FACEBOOK_APP_SECRET || secrets.DEV_FACEBOOK_APP_SECRET }}
          POSTGRES_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_POSTGRES_PASSWORD || secrets.DEV_POSTGRES_PASSWORD }}
          ENCRYPTION_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_ENCRYPTION_KEY || secrets.DEV_ENCRYPTION_KEY }}
          STRIPE_SECRET_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_SECRET_KEY || secrets.DEV_STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PUBLISHABLE_KEY || secrets.DEV_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_WEBHOOK_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_WEBHOOK_SECRET || secrets.DEV_STRIPE_WEBHOOK_SECRET }}
          STRIPE_PRICING_TABLE_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PRICING_TABLE_ID || secrets.DEV_STRIPE_PRICING_TABLE_ID }}
          STRIPE_API_VERSION=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_API_VERSION || secrets.DEV_STRIPE_API_VERSION || '2024-11-20.acacia' }}
          RESEND_API_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_API_KEY || secrets.DEV_RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_FROM_EMAIL || secrets.DEV_RESEND_FROM_EMAIL }}
          GRAFANA_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GRAFANA_PASSWORD || secrets.DEV_GRAFANA_PASSWORD || 'admin' }}
          GITHUB_REPOSITORY=${{ github.repository }}
          ENVEOF
          
          chmod 600 .env.$ENV

      - name: Deploy to server
        env:
          SSH_OPTS: "-o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
          SHORT_TAG: ${{ steps.vars.outputs.short_tag }}
        run: |
          echo "üöÄ Deploying $ENV environment (tag: $SHORT_TAG) to $SSH_USER@$SSH_HOST"
          
          # Test SSH connection
          echo "üîç Testing SSH connection..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "echo '‚úÖ SSH connection successful'" || {
            echo "‚ùå SSH connection failed! Check secrets: ${ENV}_SSH_KEY, ${ENV}_HOST, ${ENV}_USER"
            exit 1
          }
          
          # Create directories
          echo "üìÅ Creating directories..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "mkdir -p $APP_DIR/nginx"
          
          # Deploy secrets file
          echo "üîê Deploying secrets..."
          scp $SSH_OPTS .env.$ENV $SSH_USER@$SSH_HOST:/tmp/.env.$ENV.$$
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            sudo mv /tmp/.env.$ENV.$$ $APP_DIR/.env.$ENV && \
            sudo chmod 600 $APP_DIR/.env.$ENV
          "
          rm .env.$ENV
          
          # Copy application files
          echo "üì¶ Copying application files..."
          scp $SSH_OPTS docker-compose.$ENV.yml $SSH_USER@$SSH_HOST:$APP_DIR/
          scp $SSH_OPTS scripts/deploy.sh $SSH_USER@$SSH_HOST:$APP_DIR/
          
          # Copy nginx config for prod only
          if [ "$ENV" == "prod" ]; then
            scp $SSH_OPTS nginx/prod-hopper.conf $SSH_USER@$SSH_HOST:$APP_DIR/nginx/
          fi
          
          # Run deployment
          echo "üöÄ Running deployment script..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            cd $APP_DIR && \
            chmod +x deploy.sh && \
            source .env.$ENV && \
            ./deploy.sh $ENV $SHORT_TAG
          "
          
          echo "‚úÖ Deployment completed successfully!"

      - name: Cleanup secrets
        if: always()
        env:
          SSH_OPTS: "-o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
        run: |
          echo "üßπ Cleaning up secrets file..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "rm -f $APP_DIR/.env.$ENV" || echo "‚ö†Ô∏è  Cleanup failed (non-critical)"