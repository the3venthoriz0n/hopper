name: Build and Deploy

on:
  release:
    types: [created]
    # Triggers when you create a new release (which creates a git tag)
    # Note: 'dev' branch deployments are handled manually on Unraid
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip running tests'
        required: false
        default: true
        type: boolean

env:
  GHCR_REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    # Skip tests if workflow_dispatch with skip_tests=true
    # For release events, inputs.skip_tests won't exist, so tests will run normally
    if: ${{ github.event_name != 'workflow_dispatch' || inputs.skip_tests != true }}
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build backend image for testing
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: false
          load: true
          tags: hopper-backend-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was built
        run: |
          echo "ðŸ” Verifying test image exists..."
          docker images | grep hopper-backend-test || (echo "âŒ Image not found!" && exit 1)
          echo "âœ… Image verified!"

      - name: Run backend test suite
        run: |
          echo "ðŸ§ª Running backend test suite..."
          # Generate a valid Fernet key for testing (44 chars, base64-encoded)
          TEST_ENCRYPTION_KEY=$(docker run --rm hopper-backend-test:latest python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
          docker run --rm \
            -e ENCRYPTION_KEY="$TEST_ENCRYPTION_KEY" \
            -e ENVIRONMENT=test \
            -e DATABASE_URL=sqlite:///:memory: \
            -e LOG_LEVEL=INFO \
            hopper-backend-test:latest \
            python -m pytest /app/tests/ -v --tb=short -m "not skip"
          echo "âœ… Backend test suite passed!"

      - name: Build frontend image for testing
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          target: dev
          push: false
          load: true
          tags: hopper-frontend-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REACT_APP_VERSION=test

      - name: Verify frontend image was built
        run: |
          echo "ðŸ” Verifying frontend test image exists..."
          docker images | grep hopper-frontend-test || (echo "âŒ Image not found!" && exit 1)
          echo "âœ… Image verified!"

      - name: Run frontend test suite
        run: |
          echo "ðŸ§ª Running frontend test suite..."
          docker run --rm \
            -e CI=true \
            hopper-frontend-test:latest \
            npm test
          echo "âœ… Frontend test suite passed!"

      - name: Start services for integration tests
        # Skip integration tests for production releases
        if: github.event_name != 'release'
        run: |
          echo "ðŸš€ Starting services for integration tests..."
          docker network create hopper_test_network || true
          
          # Start PostgreSQL
          docker run -d --name test-postgres \
            --network hopper_test_network \
            -e POSTGRES_DB=hopper \
            -e POSTGRES_USER=hopper \
            -e POSTGRES_PASSWORD=test_password \
            postgres:16-alpine
          
          # Start Redis
          docker run -d --name test-redis \
            --network hopper_test_network \
            redis:7-alpine
          
          # Wait for services to be ready
          echo "â³ Waiting for services to start..."
          sleep 5
          
          # Wait for PostgreSQL
          until docker exec test-postgres pg_isready -U hopper; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done
          
          # Wait for Redis
          until docker exec test-redis redis-cli ping; do
            echo "Waiting for Redis..."
            sleep 2
          done

      - name: Start backend for integration tests
        # Skip integration tests for production releases
        if: github.event_name != 'release'
        run: |
          echo "ðŸš€ Starting backend for integration tests..."
          # Generate a valid Fernet key for testing (44 chars, base64-encoded)
          TEST_ENCRYPTION_KEY=$(docker run --rm hopper-backend-test:latest python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
          docker run -d --name test-backend \
            --network hopper_test_network \
            -e DATABASE_URL=postgresql://hopper:test_password@test-postgres:5432/hopper \
            -e REDIS_URL=redis://test-redis:6379/0 \
            -e ENVIRONMENT=test \
            -e ENCRYPTION_KEY="$TEST_ENCRYPTION_KEY" \
            -e LOG_LEVEL=INFO \
            hopper-backend-test:latest
          
          # Wait for backend to be ready
          echo "â³ Waiting for backend to start..."
          for i in {1..30}; do
            if docker exec test-backend curl -f http://localhost:8000/health >/dev/null 2>&1 || \
               docker exec test-backend wget -q --spider http://localhost:8000/health >/dev/null 2>&1; then
              echo "âœ… Backend is ready!"
              break
            fi
            # Fallback: check if container is running
            if [ "$(docker inspect -f '{{.State.Running}}' test-backend 2>/dev/null)" = "true" ]; then
              if [ $i -ge 10 ]; then
                echo "âš ï¸  Backend container is running but health endpoint not responding (may be starting)"
                break
              fi
            fi
            echo "Waiting for backend... ($i/30)"
            sleep 2
          done

      - name: Run integration tests
        # Skip integration tests for production releases
        if: github.event_name != 'release'
        run: |
          echo "ðŸ”’ Running integration tests..."
          # Generate a valid Fernet key for testing (44 chars, base64-encoded)
          TEST_ENCRYPTION_KEY=$(docker run --rm hopper-backend-test:latest python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())")
          docker run --rm \
            --network hopper_test_network \
            -e ENCRYPTION_KEY="$TEST_ENCRYPTION_KEY" \
            -e RUN_INTEGRATION_TESTS=true \
            -e TEST_BASE_URL=http://test-backend:8000 \
            -e TEST_FRONTEND_ORIGIN=http://localhost:3000 \
            hopper-backend-test:latest \
            python -m pytest /app/tests/test_integration.py -v
          echo "âœ… Integration tests passed!"

      - name: Cleanup test services
        # Skip cleanup if integration tests were skipped
        if: always() && github.event_name != 'release'
        run: |
          echo "ðŸ§¹ Cleaning up test services..."
          docker stop test-backend test-postgres test-redis 2>/dev/null || true
          docker rm test-backend test-postgres test-redis 2>/dev/null || true
          docker network rm hopper_test_network 2>/dev/null || true

  build-and-push:
    needs: test
    # Run if test succeeded or was skipped
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      env: ${{ steps.env.outputs.env }}
      tag: ${{ steps.tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment
        id: env
        run: |
          # Releases are always production
          echo "env=prod" >> $GITHUB_OUTPUT

      - name: Generate tag
        id: tag
        run: |
          # Use the release tag (e.g., v5.0.5) from the release event
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          
          if [ -n "$RELEASE_TAG" ]; then
            echo "tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
            echo "âœ… Using release tag: $RELEASE_TAG"
          else
            # Fallback: get latest tag (shouldn't happen with release trigger)
            GIT_TAG=$(git tag --sort=-version:refname | head -1 || echo "")
            if [ -n "$GIT_TAG" ]; then
              echo "tag=$GIT_TAG" >> $GITHUB_OUTPUT
              echo "âš ï¸  Using latest git tag as fallback: $GIT_TAG"
            else
              SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
              FALLBACK_TAG="${{ steps.env.outputs.env }}-${SHORT_SHA}"
              echo "tag=${FALLBACK_TAG}" >> $GITHUB_OUTPUT
              echo "âš ï¸  No tags found, using fallback: ${FALLBACK_TAG}"
            fi
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-backend:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-backend:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          build-args: |
            REACT_APP_BACKEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }}
            REACT_APP_DOMAIN=${{ steps.env.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }}
            REACT_APP_FRONTEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }}
            REACT_APP_ENVIRONMENT=${{ steps.env.outputs.env == 'prod' && 'production' || 'development' }}
            REACT_APP_VERSION=${{ steps.tag.outputs.tag }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-frontend:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-frontend:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push otel-collector
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.otel.${{ steps.env.outputs.env }}
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-otel:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-otel:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push prometheus
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.prometheus
          push: true
          build-args: |
            ENV=${{ steps.env.outputs.env }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-prometheus:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-prometheus:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push loki
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.loki.${{ steps.env.outputs.env }}
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-loki:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-loki:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push grafana
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.grafana
          push: true
          build-args: |
            ENV=${{ steps.env.outputs.env }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-grafana:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-grafana:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: [test, build-and-push]
    # Run if both succeeded (or test was skipped) and it's a release event OR manual workflow_dispatch
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && needs.build-and-push.result == 'success' && (github.event_name == 'release' || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          TAG="${{ needs.build-and-push.outputs.tag }}"
          
          # Set environment-specific variables
          if [ "$ENV" == "prod" ]; then
            echo "ssh_host=${{ secrets.PROD_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.PROD_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper-prod" >> $GITHUB_OUTPUT
          else
            echo "ssh_host=${{ secrets.DEV_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.DEV_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper-dev" >> $GITHUB_OUTPUT
          fi
          
          # Generate short tag for display/deployment script
          # For version tags (v5.0.5), use as-is
          # For fallback tags (prod-e366b5a), use full tag to match image tags
          if [[ "$TAG" =~ ^v[0-9] ]]; then
            echo "short_tag=$TAG" >> $GITHUB_OUTPUT
          else
            # Use full tag to match what was used in build-and-push
            echo "short_tag=$TAG" >> $GITHUB_OUTPUT
          fi

      - name: Set up SSH key
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key to file
          if [ "$ENV" == "prod" ]; then
            echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.DEV_SSH_KEY }}" > ~/.ssh/deploy_key
          fi
          
          chmod 600 ~/.ssh/deploy_key
          
          # Test the key format
          ssh-keygen -l -f ~/.ssh/deploy_key || {
            echo "âŒ Invalid SSH key format!"
            exit 1
          }
          
          echo "âœ… SSH key configured successfully"

      - name: Create environment file
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          # Use the actual tag used in the 'build-and-push' job
          FULL_TAG="${{ needs.build-and-push.outputs.tag }}"
          # Create .env file with all secrets
          cat > .env.$ENV << 'ENVEOF'
          ENVIRONMENT=${{ needs.build-and-push.outputs.env == 'prod' && 'production' || 'development' }}
          LOG_LEVEL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_LOG_LEVEL || secrets.DEV_LOG_LEVEL }}
          DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }}
          FRONTEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }}
          BACKEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }}
          CLOUDFLARE_ACCESS_AUD_TAG=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_AUD_TAG || secrets.DEV_CLOUDFLARE_ACCESS_AUD_TAG }}
          CLOUDFLARE_ACCESS_TEAM_DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_TEAM_DOMAIN || secrets.DEV_CLOUDFLARE_ACCESS_TEAM_DOMAIN }}
          GOOGLE_CLIENT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_ID || secrets.DEV_GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_SECRET || secrets.DEV_GOOGLE_CLIENT_SECRET }}
          GOOGLE_PROJECT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_PROJECT_ID || secrets.DEV_GOOGLE_PROJECT_ID }}
          TIKTOK_CLIENT_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_KEY || secrets.DEV_TIKTOK_CLIENT_KEY }}
          TIKTOK_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_SECRET || secrets.DEV_TIKTOK_CLIENT_SECRET }}
          INSTAGRAM_APP_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_INSTAGRAM_APP_ID || secrets.DEV_INSTAGRAM_APP_ID }}
          INSTAGRAM_APP_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_INSTAGRAM_APP_SECRET || secrets.DEV_INSTAGRAM_APP_SECRET }}
          POSTGRES_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_POSTGRES_PASSWORD || secrets.DEV_POSTGRES_PASSWORD }}
          ENCRYPTION_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_ENCRYPTION_KEY || secrets.DEV_ENCRYPTION_KEY }}
          STRIPE_SECRET_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_SECRET_KEY || secrets.DEV_STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PUBLISHABLE_KEY || secrets.DEV_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_WEBHOOK_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_WEBHOOK_SECRET || secrets.DEV_STRIPE_WEBHOOK_SECRET }}
          STRIPE_PRICING_TABLE_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PRICING_TABLE_ID || secrets.DEV_STRIPE_PRICING_TABLE_ID }}
          STRIPE_API_VERSION=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_API_VERSION || secrets.DEV_STRIPE_API_VERSION || '2024-11-20.acacia' }}
          RESEND_API_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_API_KEY || secrets.DEV_RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_FROM_EMAIL || secrets.DEV_RESEND_FROM_EMAIL }}
          GRAFANA_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GRAFANA_PASSWORD || secrets.DEV_GRAFANA_PASSWORD || 'admin' }}
          R2_ACCOUNT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_ACCOUNT_ID || secrets.DEV_R2_ACCOUNT_ID }}
          R2_ACCESS_KEY_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_ACCESS_KEY_ID || secrets.DEV_R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_SECRET_ACCESS_KEY || secrets.DEV_R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_BUCKET_NAME || secrets.DEV_R2_BUCKET_NAME }}
          R2_ENDPOINT_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_ENDPOINT_URL || secrets.DEV_R2_ENDPOINT_URL }}
          R2_PUBLIC_DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_R2_PUBLIC_DOMAIN || secrets.DEV_R2_PUBLIC_DOMAIN || '' }}
          GITHUB_REPOSITORY=${{ github.repository }}
          TAG=$FULL_TAG
          GHCR_IMAGE_BACKEND=ghcr.io/${{ github.repository }}/hopper-backend:${{ steps.vars.outputs.short_tag }}
          GHCR_IMAGE_FRONTEND=ghcr.io/${{ github.repository }}/hopper-frontend:${{ steps.vars.outputs.short_tag }}
          GHCR_IMAGE_OTEL=ghcr.io/${{ github.repository }}/hopper-otel:${{ steps.vars.outputs.short_tag }}
          GHCR_IMAGE_PROMETHEUS=ghcr.io/${{ github.repository }}/hopper-prometheus:${{ steps.vars.outputs.short_tag }}
          GHCR_IMAGE_LOKI=ghcr.io/${{ github.repository }}/hopper-loki:${{ steps.vars.outputs.short_tag }}
          GHCR_IMAGE_GRAFANA=ghcr.io/${{ github.repository }}/hopper-grafana:${{ steps.vars.outputs.short_tag }}
          ENVEOF
          
          chmod 600 .env.$ENV

      - name: Deploy to server
        env:
          SSH_OPTS: "-i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
          SHORT_TAG: ${{ steps.vars.outputs.short_tag }}
        run: |
          echo "ðŸš€ Deploying $ENV environment (tag: $SHORT_TAG) to $SSH_USER@$SSH_HOST"
          
          # Test SSH connection
          echo "ðŸ” Testing SSH connection..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "echo 'âœ… SSH connection successful'" || {
            echo "âŒ SSH connection failed!"
            echo "ðŸ’¡ Troubleshooting:"
            echo "   1. Verify ${ENV}_SSH_KEY secret contains the full private key (including -----BEGIN/END-----)"
            echo "   2. Verify the public key is in ~/.ssh/authorized_keys on the server"
            echo "   3. Check ${ENV}_HOST and ${ENV}_USER secrets are correct"
            echo "   4. Verify firewall allows SSH (port 22)"
            exit 1
          }
          
          # Create directories
          echo "ðŸ“ Creating directories..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "mkdir -p $APP_DIR/nginx $APP_DIR/scripts"
          
          # Deploy secrets file
          echo "ðŸ” Deploying secrets..."
          scp $SSH_OPTS .env.$ENV $SSH_USER@$SSH_HOST:/tmp/.env.$ENV.$$
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            sudo mv /tmp/.env.$ENV.$$ $APP_DIR/.env.$ENV && \
            sudo chmod 600 $APP_DIR/.env.$ENV
          "
          rm .env.$ENV
          
          # Copy application files
          echo "ðŸ“¦ Copying application files..."
          scp $SSH_OPTS docker-compose.$ENV.yml $SSH_USER@$SSH_HOST:$APP_DIR/
          scp $SSH_OPTS scripts/deploy.sh $SSH_USER@$SSH_HOST:$APP_DIR/
          scp $SSH_OPTS makefile $SSH_USER@$SSH_HOST:$APP_DIR/
          
          # Copy backup scripts
          echo "ðŸ“¦ Copying backup scripts..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "mkdir -p $APP_DIR/scripts"
          scp $SSH_OPTS scripts/backup-db.sh $SSH_USER@$SSH_HOST:$APP_DIR/scripts/
          scp $SSH_OPTS scripts/restore-db.sh $SSH_USER@$SSH_HOST:$APP_DIR/scripts/
          
          # Copy nginx config and SSL deployment script for prod only
          if [ "$ENV" == "prod" ]; then
            scp $SSH_OPTS nginx/prod-hopper.conf $SSH_USER@$SSH_HOST:$APP_DIR/nginx/
            scp $SSH_OPTS scripts/deploy-ssl-certs.sh $SSH_USER@$SSH_HOST:$APP_DIR/scripts/
          fi
          
          # Deploy SSL certificates (before running main deployment)
          if [ "$ENV" == "prod" ]; then
            echo "ðŸ”’ Deploying SSL certificates..."
            # Write certificates to temporary files if they exist
            if [ -n "${{ secrets.PROD_SSL_CERT }}" ] && [ -n "${{ secrets.PROD_SSL_KEY }}" ]; then
              # Create temp files with restrictive permissions
              TEMP_DIR=$(mktemp -d)
              chmod 700 "$TEMP_DIR"
              echo "${{ secrets.PROD_SSL_CERT }}" > "$TEMP_DIR/ssl_cert.pem"
              echo "${{ secrets.PROD_SSL_KEY }}" > "$TEMP_DIR/ssl_key.pem"
              chmod 600 "$TEMP_DIR/ssl_cert.pem" "$TEMP_DIR/ssl_key.pem"
              
              # Copy to server with restrictive permissions
              SERVER_TEMP=$(ssh $SSH_OPTS $SSH_USER@$SSH_HOST "mktemp -d" | tr -d '\r\n')
              scp $SSH_OPTS "$TEMP_DIR/ssl_cert.pem" $SSH_USER@$SSH_HOST:"$SERVER_TEMP/ssl_cert.pem"
              scp $SSH_OPTS "$TEMP_DIR/ssl_key.pem" $SSH_USER@$SSH_HOST:"$SERVER_TEMP/ssl_key.pem"
              
              # Clean up local temp files immediately
              rm -rf "$TEMP_DIR"
              
              # Deploy certificates and clean up server temp files
              ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
                chmod 600 $SERVER_TEMP/ssl_cert.pem $SERVER_TEMP/ssl_key.pem && \
                cd $APP_DIR && \
                chmod +x scripts/deploy-ssl-certs.sh && \
                export PROD_SSL_CERT=\$(cat $SERVER_TEMP/ssl_cert.pem) && \
                export PROD_SSL_KEY=\$(cat $SERVER_TEMP/ssl_key.pem) && \
                rm -rf $SERVER_TEMP && \
                sudo -E ./scripts/deploy-ssl-certs.sh $ENV
              " || {
                echo "âš ï¸  SSL certificate deployment failed"
                # Ensure cleanup even on failure
                ssh $SSH_OPTS $SSH_USER@$SSH_HOST "rm -rf $SERVER_TEMP" 2>/dev/null || true
                echo "   Continuing with deployment (certificates can be deployed manually)"
              }
            else
              echo "âš ï¸  SSL certificates not configured in GitHub secrets"
              echo "   Skipping SSL certificate deployment"
            fi
          fi
          
          # Run deployment
          echo "ðŸš€ Running deployment script..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            cd $APP_DIR && \
            chmod +x deploy.sh && \
            source .env.$ENV && \
            ./deploy.sh $ENV $SHORT_TAG
          "
          
          echo "âœ… Deployment completed successfully!"

      - name: Cleanup secrets
        if: failure()
        env:
          SSH_OPTS: "-i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
        run: |
          echo "ðŸ§¹ Cleaning up secrets after failed deployment..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "rm -f $APP_DIR/.env.$ENV" 2>/dev/null || true
          rm -f ~/.ssh/deploy_key