name: Build and Deploy

on:
  push:
    branches:
      - main
      # Note: 'dev' branch deployments are handled manually on Unraid

env:
  GHCR_REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      env: ${{ steps.env.outputs.env }}
      tag: ${{ steps.tag.outputs.tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment
        id: env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "env=prod" >> $GITHUB_OUTPUT
          else
            echo "env=dev" >> $GITHUB_OUTPUT
          fi

      - name: Generate tag
        id: tag
        run: |
          GIT_TAG=$(git tag --sort=-version:refname | head -1 || echo "")
          
          if [ -n "$GIT_TAG" ]; then
            echo "tag=$GIT_TAG" >> $GITHUB_OUTPUT
            echo "âœ… Using git tag: $GIT_TAG"
          else
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            FALLBACK_TAG="${{ steps.env.outputs.env }}-${SHORT_SHA}"
            echo "tag=${FALLBACK_TAG}" >> $GITHUB_OUTPUT
            echo "âš ï¸  No git tags found, using fallback: ${FALLBACK_TAG}"
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-backend:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-backend:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          build-args: |
            REACT_APP_BACKEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }}
            REACT_APP_DOMAIN=${{ steps.env.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }}
            REACT_APP_FRONTEND_URL=${{ steps.env.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }}
            REACT_APP_ENVIRONMENT=${{ steps.env.outputs.env == 'prod' && 'production' || 'development' }}
            REACT_APP_VERSION=${{ steps.tag.outputs.tag }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-frontend:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-frontend:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push otel-collector
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.otel.${{ steps.env.outputs.env }}
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-otel:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-otel:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push prometheus
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.prometheus
          push: true
          build-args: |
            ENV=${{ steps.env.outputs.env }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-prometheus:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-prometheus:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push loki
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.loki.${{ steps.env.outputs.env }}
          push: true
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-loki:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-loki:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push grafana
        uses: docker/build-push-action@v5
        with:
          context: ./monitoring
          file: ./monitoring/Dockerfile.grafana
          push: true
          build-args: |
            ENV=${{ steps.env.outputs.env }}
          tags: |
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-grafana:${{ steps.tag.outputs.tag }}
            ${{ env.GHCR_REGISTRY }}/${{ env.IMAGE_PREFIX }}/hopper-grafana:${{ steps.env.outputs.env }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          TAG="${{ needs.build-and-push.outputs.tag }}"
          
          # Set environment-specific variables
          if [ "$ENV" == "prod" ]; then
            echo "ssh_host=${{ secrets.PROD_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.PROD_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper-prod" >> $GITHUB_OUTPUT
          else
            echo "ssh_host=${{ secrets.DEV_HOST }}" >> $GITHUB_OUTPUT
            echo "ssh_user=${{ secrets.DEV_USER }}" >> $GITHUB_OUTPUT
            echo "app_dir=/opt/hopper-dev" >> $GITHUB_OUTPUT
          fi
          
          # Generate short tag
          if [[ "$TAG" =~ ^v[0-9] ]]; then
            echo "short_tag=$TAG" >> $GITHUB_OUTPUT
          else
            echo "short_tag=$(echo "$TAG" | cut -d'-' -f2-)" >> $GITHUB_OUTPUT
          fi

      - name: Set up SSH key
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key to file
          if [ "$ENV" == "prod" ]; then
            echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/deploy_key
          else
            echo "${{ secrets.DEV_SSH_KEY }}" > ~/.ssh/deploy_key
          fi
          
          chmod 600 ~/.ssh/deploy_key
          
          # Test the key format
          ssh-keygen -l -f ~/.ssh/deploy_key || {
            echo "âŒ Invalid SSH key format!"
            exit 1
          }
          
          echo "âœ… SSH key configured successfully"

      - name: Create environment file
        run: |
          ENV="${{ needs.build-and-push.outputs.env }}"
          
          # Create .env file with all secrets
          cat > .env.$ENV << 'ENVEOF'
          ENVIRONMENT=${{ needs.build-and-push.outputs.env == 'prod' && 'production' || 'development' }}
          LOG_LEVEL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_LOG_LEVEL || secrets.DEV_LOG_LEVEL }}
          DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_DOMAIN || secrets.DEV_DOMAIN }}
          FRONTEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FRONTEND_URL || secrets.DEV_FRONTEND_URL }}
          BACKEND_URL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_BACKEND_URL || secrets.DEV_BACKEND_URL }}
          CLOUDFLARE_ACCESS_AUD_TAG=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_AUD_TAG || secrets.DEV_CLOUDFLARE_ACCESS_AUD_TAG }}
          CLOUDFLARE_ACCESS_TEAM_DOMAIN=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_CLOUDFLARE_ACCESS_TEAM_DOMAIN || secrets.DEV_CLOUDFLARE_ACCESS_TEAM_DOMAIN }}
          GOOGLE_CLIENT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_ID || secrets.DEV_GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_CLIENT_SECRET || secrets.DEV_GOOGLE_CLIENT_SECRET }}
          GOOGLE_PROJECT_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GOOGLE_PROJECT_ID || secrets.DEV_GOOGLE_PROJECT_ID }}
          TIKTOK_CLIENT_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_KEY || secrets.DEV_TIKTOK_CLIENT_KEY }}
          TIKTOK_CLIENT_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_TIKTOK_CLIENT_SECRET || secrets.DEV_TIKTOK_CLIENT_SECRET }}
          FACEBOOK_APP_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FACEBOOK_APP_ID || secrets.DEV_FACEBOOK_APP_ID }}
          FACEBOOK_APP_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_FACEBOOK_APP_SECRET || secrets.DEV_FACEBOOK_APP_SECRET }}
          POSTGRES_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_POSTGRES_PASSWORD || secrets.DEV_POSTGRES_PASSWORD }}
          ENCRYPTION_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_ENCRYPTION_KEY || secrets.DEV_ENCRYPTION_KEY }}
          STRIPE_SECRET_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_SECRET_KEY || secrets.DEV_STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PUBLISHABLE_KEY || secrets.DEV_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_WEBHOOK_SECRET=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_WEBHOOK_SECRET || secrets.DEV_STRIPE_WEBHOOK_SECRET }}
          STRIPE_PRICING_TABLE_ID=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_PRICING_TABLE_ID || secrets.DEV_STRIPE_PRICING_TABLE_ID }}
          STRIPE_API_VERSION=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_STRIPE_API_VERSION || secrets.DEV_STRIPE_API_VERSION || '2024-11-20.acacia' }}
          RESEND_API_KEY=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_API_KEY || secrets.DEV_RESEND_API_KEY }}
          RESEND_FROM_EMAIL=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_RESEND_FROM_EMAIL || secrets.DEV_RESEND_FROM_EMAIL }}
          GRAFANA_PASSWORD=${{ needs.build-and-push.outputs.env == 'prod' && secrets.PROD_GRAFANA_PASSWORD || secrets.DEV_GRAFANA_PASSWORD || 'admin' }}
          GITHUB_REPOSITORY=${{ github.repository }}
          ENVEOF
          
          chmod 600 .env.$ENV

      - name: Deploy to server
        env:
          SSH_OPTS: "-i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
          SHORT_TAG: ${{ steps.vars.outputs.short_tag }}
        run: |
          echo "ðŸš€ Deploying $ENV environment (tag: $SHORT_TAG) to $SSH_USER@$SSH_HOST"
          
          # Test SSH connection
          echo "ðŸ” Testing SSH connection..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "echo 'âœ… SSH connection successful'" || {
            echo "âŒ SSH connection failed!"
            echo "ðŸ’¡ Troubleshooting:"
            echo "   1. Verify ${ENV}_SSH_KEY secret contains the full private key (including -----BEGIN/END-----)"
            echo "   2. Verify the public key is in ~/.ssh/authorized_keys on the server"
            echo "   3. Check ${ENV}_HOST and ${ENV}_USER secrets are correct"
            echo "   4. Verify firewall allows SSH (port 22)"
            exit 1
          }
          
          # Create directories
          echo "ðŸ“ Creating directories..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "mkdir -p $APP_DIR/nginx"
          
          # Deploy secrets file
          echo "ðŸ” Deploying secrets..."
          scp $SSH_OPTS .env.$ENV $SSH_USER@$SSH_HOST:/tmp/.env.$ENV.$$
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            sudo mv /tmp/.env.$ENV.$$ $APP_DIR/.env.$ENV && \
            sudo chmod 600 $APP_DIR/.env.$ENV
          "
          rm .env.$ENV
          
          # Copy application files
          echo "ðŸ“¦ Copying application files..."
          scp $SSH_OPTS docker-compose.$ENV.yml $SSH_USER@$SSH_HOST:$APP_DIR/
          scp $SSH_OPTS scripts/deploy.sh $SSH_USER@$SSH_HOST:$APP_DIR/
          
          # Copy nginx config for prod only
          if [ "$ENV" == "prod" ]; then
            scp $SSH_OPTS nginx/prod-hopper.conf $SSH_USER@$SSH_HOST:$APP_DIR/nginx/
          fi
          
          # Run deployment
          echo "ðŸš€ Running deployment script..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "
            cd $APP_DIR && \
            chmod +x deploy.sh && \
            source .env.$ENV && \
            ./deploy.sh $ENV $SHORT_TAG
          "
          
          echo "âœ… Deployment completed successfully!"

      - name: Cleanup secrets
        if: always()
        env:
          SSH_OPTS: "-i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o IdentitiesOnly=yes"
          SSH_HOST: ${{ steps.vars.outputs.ssh_host }}
          SSH_USER: ${{ steps.vars.outputs.ssh_user }}
          APP_DIR: ${{ steps.vars.outputs.app_dir }}
          ENV: ${{ needs.build-and-push.outputs.env }}
        run: |
          echo "ðŸ§¹ Cleaning up secrets..."
          ssh $SSH_OPTS $SSH_USER@$SSH_HOST "rm -f $APP_DIR/.env.$ENV" 2>/dev/null || true
          rm -f ~/.ssh/deploy_key